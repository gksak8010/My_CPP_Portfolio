1. 프로젝트 개요
  C++의 객체 지향 프로그래밍 원칙과 동적 메모리 관리를 기반으로, 콘솔 환경에서 실시간으로 동작하는 텍스트 기반 유저 인터페이스 게임 2종을 개발했습니다.
  표준 C++ 라이브러리를 넘어 Win32 API를 직접 활용하여 화면을 제어하고, GameManager 중심의 설계를 통해 '몬스터 잡기'와 '장애물 피하기'라는 두가지 다른 게임 로직을 효율적으로 구현했습니다.

2. 주요기능


3. 적용된 핵심 기술
  1) Win32 API를 활용한 Text-based UI 구현
    단순히 텍스트가 흐르는 std::cout 방식에서 벗어나, Windows.h의 SetConsoleCursorPosition API를 GotoXY 함수로 캡슐화했습니다.
    이를 통해 콘솔 화면의 특정 좌표에 맵, 플레이어, 점수판을 지속적으로 갱신하는 동적인 TUI를 구현했습니다.
    또한, _kbhit을 사용한 실시간 키보드 입력 처리로 사용자의 조작에 즉각 반응하는 게임 루프를 완성했습니다.

  2) 이중 포인터를 이용한 동적 메모리 관리
    게임 맵의 크기가 유동적이거나 클 경우를 대비하여, char** map 이중 포인터를 사용해 맵 데이터를 힙(Heap) 메모리에 동적 할당했습니다.
    GameManager의 생성자에서 new[] 를 통해 2차원 맵을 생성하고, 소멸자에서 delete[]를 호출하여 할당된 메모리를 정확히 해제함으로써 메모리 누수를 방지했습니다.

  3) 객체 지향 설계 기반의 로직 분리
    Character, Item, Hurdle, GameManager 클래스로 역할과 책임을 명확히 분리했습니다.
    특히, GameManager가 게임의 핵심 로직(맵 세팅, 충돌 감지, 화면 표시)을 전담하도록 설계하여, Character와 Item 객체는 자신의 상태(좌표, 생존 여부)만 관리하도록 했습니다.
    이는 코드의 유지보수성을 높여주었습니다.

  4) 알고리즘(Fisher-Yates shuffle)의 실제 적용
    게임의 공정성과 재미를 위해, 몬스터와 아이템을 무작위 위치에 배치하는 로직이 필요했습니다.
    std::rand와 std::swap을 활용하여, Fisher-Yates shuffle 알고리즘을 구현하였고, 이를 통해 게임 시작 시 모든 객체가 중복 없이 공정한 랜덤 위치에 생성되도록 적용했습니다.

4. 배운 점 및 개선점
  이번 프로젝트를 통해 C++의 문법 학습을 넘어, 완성도 있는 애플리케이션을 만드는 데 필요한 세 가지 핵심 요소를 배울 수 있었습니다.
    -설계의 중요성
    단순히 main 함수에 모든 코드를 작성하는 것이 아니라, GameManager, Character 등 클래스로 기능을 분리해야만 게임 루프, 충돌 감지,
    렌더링 같은 복잡한 로직을 체계적으로 관리할 수 있음을 깨달았습니다.

    -메모리 관리의 필요성
    게임 맵처럼 크기가 유동적인 데이터를 다루기 위해서는 new[]와 delete[]를 사용한 동적 할당이 필수적임을 배웠습니다.
    특히, 생성자와 소멸자를 활용해 메모리 할당과 해제츨 자동으로 관리하여 안정성을 높이는 방법을 체득했습니다.

    -플랫폼에 대한 이해
    표준 C++만으로는 GotoXY 같은 화면 제어가 불가능했습니다.
    Win32 API와 같은 운영체제의 기능을 직접 활용해야 비로소 정적인 코드가 동적인 TUI 애플리케이션으로 완성될 수 있음을 경험했습니다.

  그에 따른 개선점 역시 발견할 수 있었습니다.
    -수동 delete[] 방식은 코드가 복잡해지면 실수로 메모리 누수를 유발할 수 있습니다.
    이 부분을 C++11의 스마트 포인터(std::unique)나 std::vector로 교체하여, 자원이 자동으로 관리되도록 리팩토링하고 싶습니다.

    -Character, Item, Hurdle이 비록 지금은 다른 클래스지만, 화면에 그려져야 한다는 공통점이 있습니다. 이들을 공통 부모 클래스로 묶고 Draw()를 가상함수로 만들어 다형성을 적용하고 싶습니다.
    이렇게 하면 GameManager는 단 하나의 리스트로 모든 객체를 효율적으로 관리할 수 있습니다.

    -C-style 배열 대신 std::vector 같은 STL 컨테이너를 사용하면, 몬스터나 아이템의 최대 개수를 하드코딩할 필요 없이 동적으로 추가하거나 제거하기 훨씬 용이해집니다.
    그것을 개선하고 싶습니다.

    -GotoXY나 _kbhit은 윈도우 전용 API라서 리눅스 등 다른 OS에서는 컴파일되지 않습니다.
    만약 이식성이 필요하다면, ncurese 같은 크로스 플랫폼 TUI 라이브러리를 학습하여 적용하는 방향으로 개선할 수 있습니다.
